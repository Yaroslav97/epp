Архитектура и проектирование ПО

1. Архитектура ПО. Основное назначение архитектуры ПО.

Создание архитектуры приложения – это процесс формирования структурированного
решения, отвечающего всем техническим и операционным требованиям и обеспечивающего оптимальные общие атрибуты качества, такие как производительность, безопасность и управляемость. Он включает принятие ряда решений на основании широкого диапазона факторов. Каждое из этих решений может иметь существенное влияние на качество, производительность, удобство обслуживания и общий успех приложения.
Архитектура программной или вычислительной системы – это структура или структуры
системы, включающие программные элементы, видимые извне свойства этих элементов
и взаимоотношения между ними.
Неправильное определение ключевых сценариев, неправильное проектирование общих
вопросов или неспособность выявить долгосрочные последствия основных решений могут поставить под угрозу все приложение.

2. Основные вопросы при разработке архитектуры ПО, при тестировании архитектуры ПО.

●	  Как пользователь будет использовать приложение?
●	  Как приложение будет развертываться и обслуживаться при эксплуатации?
●	  Какие требования по атрибутам качества, таким как безопасность, производительность, возможность параллельной обработки, интернационализация и конфигурация, выдвигаются к приложению?
●	  Как спроектировать приложение, чтобы оно оставалось гибким и удобным в обслуживании в течение долгого времени?
●	  Основные архитектурные направления, которые могут оказывать влияние на приложение сейчас или после его развертывания?

При тестировании архитектуры дайте ответы на следующие вопросы:
●	  Какие допущения были сделаны в этой архитектуре?
●	  Каким явным или подразумеваемым требованиям отвечает данная архитектура?
●	  Основные риски при использовании такого архитектурного решения?
●	  Каковы меры противодействия для снижения основных рисков?
●	  Является ли данная архитектура улучшением базовой архитектуры или одним из возможных вариантов архитектуры?

3. Цели архитектуры ПО. Основные вопросы, которые должен учитывать архитектор ПО.

Архитектура приложения должна объединять бизнес-требования и технические требования через понимание вариантов использования с последующим нахождением путей их реализации в ПО. Цель архитектуры – выявить требования, оказывающие влияние на структуру приложения. Хорошая архитектура снижает бизнес-риски, связанные с созданием технического решения. Хорошая структура обладает значительной гибкостью, чтобы справляться с естественным развитием технологий, как в области оборудования и ПО, так и пользовательских сценариев и требований. Архитектор должен учитывать общий эффект от принимаемых проектных решений, обязательно присутствующие компромиссы между атрибутами качества (такими как производительность и безопасность) и компромиссы, необходимые для выполнения пользовательских, системных и бизнес-требований.
Необходимо помнить, что архитектура должна:
●	  Раскрывать структуру системы, но скрывать детали реализации.
●	  Реализовывать все варианты использования и сценарии.
●	  По возможности отвечать всем требованиям различных заинтересованных сторон.
●	  Выполнять требования, как по функциональности, так и по качеству.

При проектировании архитектуры необходимо ответить на следующие вопросы:
●	  Какие части архитектуры являются фундаментальными, изменение которых в случае неверной реализации представляет наибольшие риски?
●	  Какие части архитектуры вероятнее всего подвергнуться изменениям, а также проектирование каких частей можно отложить?
●	  Основные допущения, и как они будут проверяться?
●	  Какие условия могут привести к реструктуризации дизайна?

4. Принципы проектирования архитектуры ПО.

●	Создавайте, чтобы изменять.
●	Создавайте модели для анализа и сокращения рисков.
●	Используйте модели и визуализации как средства общения при совместной работе.
●	Выявляйте ключевые инженерные решения.
+ вопрос 6

5. Типовая архитектура приложения, компоненты которого сгруппированы по функциональным областям.



6. Основные принципы проектирования. Практики проектирования.

●	  Разделение функций. Разделите приложение на отдельные компоненты, по
возможности, с минимальным перекрытием функциональности. Важным фактором
является предельное уменьшение количества точек соприкосновения, что
обеспечит высокую связность (high cohesion) и слабую связанность (low coupling).
Неверное разграничение функциональности может привести к высокой связанности
и сложностям взаимодействия, даже несмотря на слабое перекрытие
функциональности отдельных компонентов.
●	  Принцип единственности ответственности. Каждый отдельно взятый компонент
или модуль должен отвечать только за одно конкретное свойство/функцию или
совокупность связанных функций.
●	  Принцип минимального знания (также известный как Закон Деметера (Law of
Demeter, LoD)). Компоненту или объекту не должны быть известны внутренние
детали других компонентов или объектов.
●	  Не повторяйтесь (Don’t repeat yourself, DRY).
определенная функциональность должна быть реализована только в одном
компоненте и не должна дублироваться ни в одном другом компоненте.
●	  Минимизируйте проектирование наперед. Проектируйте только то, что
необходимо. В некоторых случаях, когда стоимость разработки или издержки в
случае неудачного дизайна очень высоки, может потребоваться полное
предварительное проектирование и тестирование. В других случаях, особенно при
гибкой разработке, можно избежать масштабного проектирования наперед. Если требования к приложению четко не определены, или существует вероятность изменения дизайна со временем, старайтесь не тратить много сил на проектирование раньше времени. Этот принцип называют YAGNI («You ain’t gonna need it»).

+ вопрос 4

Практики проектирования:
●	Придерживайтесь единообразия шаблонов проектирования в рамках одного слоя.
●	Не дублируйте функциональность в приложении
●	Предпочитайте композицию наследованию
●	Применяйте определенный стиль написания кода и соглашение о присваивании имен для разработки
●	Обеспечивайте качество системы во время разработки с помощью методик автоматизированного QA
●	Учитывайте условия эксплуатации приложения

7. Слои приложения.

Многоуровневая архитектура обеспечивает группировку связанной функциональности
приложения в разных слоях, выстраиваемых вертикально, поверх друг друга.
Функциональность каждого слоя объединена общей ролью или ответственностью. Слои слабо связаны, и между ними осуществляется явный обмен данными. Правильное разделение приложения на слои помогает поддерживать строгое разделение функциональности, что в свою очередь, обеспечивает гибкость, а также удобство и простоту обслуживания.

●	  Разделяйте функциональные области. Разделите приложение на отдельные
функции с, по возможности, минимальным перекрытием функциональности.
Основное преимущество такого подхода – независимая оптимизация
функциональных возможностей. Кроме того, сбой одной из функций не приведет к
сбою остальных, поскольку они могут выполняться независимо друг от друга. Такой
подход также упрощает понимание и проектирование приложения и облегчает
управление сложными взаимосвязанными системами.
●	  Явно определяйте связи между слоями. Решение, в котором каждый слой
приложения может взаимодействовать или имеет зависимости со всеми
остальными слоями, является сложным для понимания и управления. Принимайте
явные решения о зависимостях между слоями и о потоках данных между ними.
●	  Реализуйте слабое связывание слоев с помощью абстракции. Это можно
реализовать, определяя интерфейсные компоненты с хорошо известными
входными и выходными характеристиками, такие как фасад, которые преобразуют
запросы в формат, понятный компонентам слоя. Кроме того, также можно
определять общий интерфейс или совместно используемую абстракцию
(противоположность зависимости), которые должны быть реализованы
компонентами интерфейса, используя интерфейсы или абстрактные базовые
классы.
●	  Не смешивайте разные типы компонентов на одном логическом уровне.
Начинайте с идентификации функциональных областей и затем группируйте
компоненты, ассоциированные с каждой из этих областей в логические уровни.
Например, слой UI не должен включать компоненты выполнения бизнес-процессов,
в него должны входить только компоненты, используемые для обработки
пользовательского ввода и запросов.
●	  Придерживайтесь единого формата данных в рамках слоя или компонента.
Смешение форматов данных усложнит реализацию, расширение и обслуживание
приложения. Любое преобразование одного формата данных в другой требует
реализации кода преобразования и влечет за собой издержки на обработку.

8. Компоненты, модули и функции.
●	  Компонент или объект не должен полагаться на внутренние данные других
компонентов или объектов. Каждый метод, вызываемый компонентом или
методом другого объекта или компонента, должен располагать достаточными
сведениями о том, как обрабатывать поступающие запросы и, в случае
необходимости, как перенаправлять их к соответствующим подкомпонентам или другим компонентам. Это способствует созданию более удобных в обслуживании и
адаптируемых приложений.
●	  Не перегружайте компонент функциональностью. Например, компонент UI не
должен включать код для доступа к данным или обеспечивать дополнительную
функциональность. Перегруженные компоненты часто имеют множество функций и
свойств, сочетая бизнес-функциональность и сквозную функциональность, такие как
протоколирование и обработка исключений. В результате получается очень
неустойчивый к ошибкам и сложный в обслуживании дизайн. Применение
принципов исключительной ответственности и разделения функциональности
поможет избежать этого.
●	  Разберитесь с тем, как будет осуществляться связь между компонентами. Это
требует понимания сценариев развертывания, которые должно поддерживать
создаваемое приложение. Необходимо определить, будут ли все компоненты
выполняться в рамках одного процесса или необходимо обеспечить поддержку
связи через физические границы или границы процесса, вероятно, путем
реализации интерфейсов взаимодействия на основе сообщений.
●	  Максимально изолируйте сквозную функциональность от бизнес-логики
приложения. Сквозная функциональность – это аспекты безопасности, обмена
информацией или управляемости, такие как протоколирование и
инструментирование. Смешение кода, реализующего эти функции, с бизнес-логикой может привести к созданию дизайна, который будет сложно расширять и
обслуживать. Внесение изменений в сквозную функциональность потребует
переработки всего кода бизнес-логики. Рассмотрите возможность использования
инфраструктур и методик (таких как аспект-ориентированное программирование),
которые помогут в реализации такой функциональности.
●	  Определяйте четкий контракт для компонентов. Компоненты, модули и функции
должны определять контракт или спецификацию интерфейса, четко
оговаривающую их использование и поведение. Контракт должен описывать, как
другие компоненты могут выполнять доступ к внутренней функциональности
компонента, модуля или функции, и поведение этой функциональности с точки
зрения предварительных условий, постусловий, побочных эффектов, исключений,
рабочих характеристик и других факторов.

9. Основные вопросы проектирования.
●	  Определение типа приложения
●	  Выбор стратегии развертывания
●	  Выбор соответствующих технологий
●	  Выбор показателей качества
●	  Решение о путях реализации сквозной функциональности

10. Определение типа приложения.
Основные типы приложений:
●	  Приложения для мобильных устройств.
●	  Насыщенные клиентские приложения для выполнения преимущественно на клиентских ПК.
●	  Насыщенные клиентские приложения для развертывания из Интернета с поддержкой насыщенных UI и мультимедийных сценариев.
●	  Сервисы, разработанные для обеспечения связи между слабо связанными компонентами.
●	  Веб-приложения для выполнения преимущественно на сервере в сценариях с постоянным подключением.
+ Специальные типы:
●	Приложения и сервисы, размещаемые в центрах обработки данных (ЦОД) и в облаке.
●	Офисные бизнес-приложения (Office Business Applications, OBAs), интегрирующие технологии Microsoft Office и Microsoft Server.
●	Бизнес-приложения SharePoint (SharePoint Line of Business, LOB), обеспечивающие доступ к бизнес-данным и функциональным возможностям через портал.

11. Выбор стратегии развертывания.
Приложение может развертываться в разнообразнейших средах, каждая из которых будет
иметь собственный набор ограничений, таких как физическое распределение компонентов по серверам, ограничение по используемым сетевым протоколам, настройки межсетевых экранов и маршрутизаторов и многое другое. Существует несколько общих схем развертывания, которые описывают преимущества и мотивы применения ряда
распределенных и нераспределенных сценариев. При выборе стратегии необходимо найти компромисс между требованиями приложения и соответствующими схемами развертывания,поддерживаемым оборудованием, и ограничениями, налагаемыми средой на варианты развертывания. Все эти факторы будут влиять на проектируемую архитектуру.

12. Выбор соответствующих технологий.
Ключевым фактором при выборе технологий для приложения является тип разрабатываемого приложения, а также предпочтительные варианты топологии развертывания приложения и архитектурные стили. Выбор технологий также определяется политиками организации, ограничениями среды, квалификацией ресурсов и т.д. Необходимо сравнить возможности выбираемых технологий с требованиями приложения, принимая во внимание все эти факторы.





13. Выбор показателей качества.

Показатели качества, такие как безопасность, производительность, удобство и простота
использования, помогают сфокусировать внимание на критически важных проблемах, которые должен решать создаваемый дизайн. В зависимости от конкретных требований может понадобиться рассмотреть некоторые показатели качества. Например, вопросы безопасности и производительности необходимо учесть при разработке каждого приложения, тогда как проблемы возможности взаимодействия или масштабируемости стоят далеко не перед всеми проектами. Первым делом, необходимо понять поставленные требования и сценарии развертывания, чтобы знать, какие показатели качества важны для создаваемого приложения. Нельзя также забывать о возможности конфликта между показателями качества. Например, часто требования безопасности идут вразрез с производительностью или удобством использования. При проектировании с учетом показателей качества следует руководствоваться следующим:
●	  Показатели качества – это свойства системы, отделенные от ее функциональности.
●	  С технической точки зрения, реализованные показатели качества отличают
хорошую систему от плохой.
●	  Существует два типа показателей качества: измеряемые во время выполнения и те, оценить которые можно только посредством проверки.
●	  Необходимо провести анализ и найти оптимальное соотношение между
показателями качества.

Вопросы, на которые необходимо ответить при рассмотрении показателей качества:
●	  Каковы основные показатели качества приложения? Определите их в ходе процесса разработки.
●	  Каковы основные требования для реализации этих показателей? Поддаются ли они
количественному определению?
●	  Каковы критерии приемки, которые будут свидетельствовать о выполнении
требований?

14. Решение о путях реализации сквозной функциональности.

Сквозная функциональность представляет ключевую область дизайна, не связанную с
конкретным функционалом приложения. Например, необходимо рассмотреть возможности
реализации централизованных или общих решений для следующих аспектов:
  Механизм протоколирования, обеспечивающий возможность каждому слою вести
журнал в общем хранилище либо в разных хранилищах, но таким образом, чтобы
результаты могли быть сопоставлены впоследствии.
  Механизмы аутентификации и авторизации, обеспечивающие передачу
удостоверений на разные уровни для предоставления доступа к ресурсам.
  Инфраструктура управления исключениями, которая будет функционировать в
каждом слое и между уровнями, если исключения распространяются в рамках
системы.  Подход к реализации связей, используемый для обеспечения обмена информацией между слоями.
  Общая инфраструктура кэширования, позволяющая кэшировать данные в слое
представления, бизнес-слое и слое доступа к данным.
В следующем списке приведены основные аспекты сквозной функциональности, которые
необходимо рассмотреть при создании архитектуры приложений:
●	  Инструментирование и протоколирование. Обеспечивайте управление и
мониторинг всех критически важных для бизнес-логики и системы событий.
Протоколируйте достаточное количество сведений для воссоздания событий в
системе без включения конфиденциальных данных.
●	  Аутентификация. Определитесь с тем, как будет проходить аутентификация
пользователей и передача аутентифицированных удостоверений между слоями.
●	  Авторизация. На каждом уровне и между границами доверия обеспечьте
соответствующую авторизацию с необходимой детализацией.
●	  Управление исключениями. Перехватывайте исключения на функциональных,
логических и физических границах и избегайте раскрытия конфиденциальных
сведений конечным пользователям.
●	  Связь. Выберите соответствующие протоколы, сведите до минимума количество
вызовов по сети и защитите передачу конфиденциальных данных по сети.
●	  Кэширование. Определите, что должно кэшироваться и где для улучшения
производительности и сокращения времени отклика приложения. При
проектировании кэширования не забудьте учесть особенности Веб-фермы и фермы
приложений.

15. Основные фокусные области и соответствующие архитектурные стили.
Архитектурный стиль, иногда называемый архитектурным шаблоном – это набор принципов, высокоуровневая схема, обеспечивающая абстрактную инфраструктуру для семейства систем. Архитектурный стиль улучшает секционирование и способствует повторному использованию дизайна благодаря обеспечению решений часто встречающихся проблем. Архитектурные стили и шаблоны можно рассматривать как набор принципов, формирующих приложение. Архитектурный стиль определяет набор компонентов и соединений, которые могут использоваться в экземплярах этого стиля, а также ряд ограничений по их возможным сочетаниям. Сюда могут относиться топологические ограничения на архитектурные решения (например, не использовать циклы). Описание стиля также может включать и другие ограничения, такие как, скажем, необходимость обработки семантики выполнения.» Понимание архитектурных стилей обеспечивает несколько преимуществ. Самое главное из них – общий язык. Также они дают возможность вести диалог, не касаясь технологий, т.е.
обсуждать схемы и принципы, не вдаваясь в детали. Например, архитектурные стили
позволяют сравнивать схему клиент/сервер с n-уровневой схемой приложения. Архитектурные стили можно организовать по их фокусу. В следующей таблице перечислены основные фокусные области и соответствующие архитектурные стили.




16. Основные архитектурные стили.



17. Сочетание архитектурных стилей.
Архитектура программной системы практически никогда не ограничена лишь одним
архитектурным стилем, зачастую она является сочетанием архитектурных стилей, образующих полную систему. Например, может существовать SOA-дизайн, состоящий из сервисов, при разработке которых использовалась многослойная архитектура и объектно-ориентированный архитектурный стиль.
Сочетание архитектурных стилей также полезно при построении Интернет Веб-приложений, где можно достичь эффективного разделения функциональности за счет применения многослойного архитектурного стиля. Таким образом можно отделить логику представления от бизнес-логики и логики доступа к данным. Требования безопасности организации могут обусловливать либо 3-уровневое развертывание приложения, либо развертывание с более чем тремя уровнями. Уровень представления может развертываться в пограничной сети, располагающейся между внутренней сетью организации и внешней сетью. В качестве модели взаимодействия на уровне представления может применяться шаблон представления с отделением (разновидность многослойного стиля), такая как Model-View-Controller (MVC)5.
Также можно выбрать архитектурный стиль SOA и реализовать связь между Веб-сервером и сервером приложений посредством обмена сообщениями.
Создавая настольное приложение, можно реализовать клиент, который будет отправлять
запросы к программе на сервере. В этом случае развертывание клиента и сервера можно
выполнить с помощью архитектурного стиля клиент/сервер и использовать компонентную
архитектуру для дальнейшего разложения дизайна на независимые компоненты,
предоставляющие соответствующие интерфейсы. Применение объектно-ориентированного подхода к этим компонентам повысит возможности повторного использования, тестирования и гибкость.
На выбор архитектурных стилей оказывает влияние множество факторов. Сюда входят
способность организации к проектированию и реализации, возможности и опыт
разработчиков, а также ограничения инфраструктуры и организации. Информация,
приведенная в следующих разделах, поможет при выборе соответствующих стилей для
приложений.


18. Архитектура клиент/сервер.
Клиент/серверная архитектура описывает распределенные системы, состоящие из отдельных клиента и сервера и соединяющей их сети. Простейшая форма системы клиент/сервер, называемая 2-уровневой архитектурой – это серверное приложение, к которому напрямую обращаются множество клиентов.
Исторически архитектура клиент/сервер представляет собой настольное приложение с
графическим UI, обменивающееся данными с сервером базы данных, на котором в форме
хранимых процедур располагается основная часть бизнес-логики, или с выделенным
файловым сервером. Если рассматривать более обобщенно, архитектурный стиль
клиент/сервер описывает отношения между клиентом и одним или более серверами, где
клиент инициирует один или более запросов (возможно, с использованием графического UI), ожидает ответы и обрабатывает их при получении. Обычно сервер авторизует пользователя и затем проводит обработку, необходимую для получения результата. Для связи с клиентом сервер может использовать широкий диапазон протоколов и форматов данных. На сегодняшний день примерами архитектурного стиля клиент/сервер могут служить Веб-приложения, выполняющиеся в Интернете или внутренних сетях организаций; настольные приложения для операционной системы Microsoft Windows®, выполняющие доступ к сетевым сервисам данных; приложения, выполняющие доступ к удаленным хранилищам данных (такие как программы чтения электронной почты, FTP-клиенты и средства доступа к базам данных); инструменты и утилиты для работы с удаленными системами (такие как средства управления системой и средства мониторинга сети). К другим разновидностям стиля клиент/сервер относятся:
  Системы клиент-очередь-клиент. Этот подход позволяет клиентам обмениваться
данными с другими клиентами через очередь на сервере. Клиенты могут читать
данные с и отправлять данные на сервер, который выступает в роли простой очереди
для хранения данных. Благодаря этому клиенты могут распределять и
синхронизировать файлы и сведения. Иногда такую архитектуру называют пассивной
очередью. Одноранговые (Peer-to-Peer, P2P) приложения. Созданный на базе клиент-очередь-клиент, стиль P2P позволяет клиенту и серверу обмениваться ролями с целью распределения и синхронизации файлов и данных между множеством клиентов. Эта схема расширяет стиль клиент/сервер, добавляя множественные ответы на запросы,
совместно используемые данные, обнаружение ресурсов и устойчивость при удалении
участников сети. Серверы приложений. Специализированный архитектурный стиль, при котором приложения и сервисы размещаются и выполняются на сервере, и тонкий клиент
 выполняет доступ к ним через браузер или специальное установленное на клиенте ПО.
Примером является клиент, который работает с приложением, выполняющимся на
сервере, через такую среду как Terminal Services (Службы терминалов).
Основные преимущества архитектурного стиля клиент/сервер:
  Большая безопасность. Все данные хранятся на сервере, который обычно
обеспечивает больший контроль безопасности, чем клиентские компьютеры.
  Централизованный доступ к данным. Поскольку данные хранятся только на сервере,
администрирование доступа к данным намного проще, чем в любых других
архитектурных стилях. Простота обслуживания. Роли и ответственность вычислительной системы распределены между несколькими серверами, общающимися друг с другом по сети. Благодаря этому клиент гарантированно остается неосведомленным и не
подверженным влиянию событий, происходящих с сервером (ремонт, обновление
либо перемещение). Возможность применения архитектуры клиент/сервер рассматривается если создаваемое приложение должно размещаться на сервере и не должно поддерживать множество клиентов; если создаются Веб-приложения, предоставляемые через Веб-браузер; если реализуются бизнес-процессы, которые будут использоваться в рамках организации; или если создаются сервисы для использования другими приложениями.
Архитектурный стиль клиент/сервер, как и многие стили сетевых приложений, также подходит, если необходимо централизовать хранилище данных, функции резервного копирования и управления, или если разрабатываемое приложение должно поддерживать разные типы клиентов и разные устройства.
Тем не менее, традиционная 2-уровневая архитектура клиент/сервер имеет множество недостатков, включая тенденцию тесного связывания данных и бизнес-логики приложения на сервере, что может иметь негативное влияние на расширяемость и масштабируемость системы, и зависимость от центрального сервера, что негативно сказывается на надежности системы. Для решения этих проблем архитектурный стиль клиент/сервер был развит в более универсальный 3-уровневый (или N-уровневый), в котором устранены некоторые недостатки, свойственные 2-уровневой архитектуре клиент/сервер, и обеспечиваются дополнительные преимущества.



19. Компонентная архитектура.
Компонентная архитектура описывает подход к проектированию и разработке систем с
использованием методов проектирования программного обеспечения. Основное внимание в этом случае уделяется разложению дизайна на отдельные функциональные или логические компоненты, предоставляющие четко определенные интерфейсы, содержащие методы, события и свойства. В данном случае обеспечивается более высокий уровень абстракции, чем при объектно-ориентированной разработке, и не происходит концентрации внимания на таких вопросах, как протоколы связи или общее состояние.
Основной принцип компонентного стиля – применение компонентов, обладающих
следующими качествами:
●	  Пригодность для повторного использования. Как правило, компоненты проектируются с обеспечением возможности их повторного использования в разных сценариях различных приложений. Однако некоторые компоненты создаются специально для конкретной задачи.
●	  Замещаемость. Компоненты могут без труда заменяться другими подобными
компонентами.
●	  Независимость от контекста. Компоненты проектируются для работы в разных средах и контекстах. Специальные сведения, такие как данные о состоянии, должны не включаться или извлекаться компонентом, а передаваться в него.
●	  Расширяемость. Компонент может расширять существующие компоненты для
обеспечения нового поведения.
●	  Инкапсуляция. Компоненты предоставляют интерфейсы, позволяющие вызывающей стороне использовать их функциональность, не раскрывая при этом детали внутренних процессов либо внутренние переменные или состояние.
●	  Независимость. Компоненты проектируются с минимальными зависимостями от
других компонентов.
Таким образом, компоненты могут быть развернуты в любой
подходящей среде без влияния на другие компоненты или системы.Обычно в приложениях используются компоненты пользовательского интерфейса (их часто
называют элементами управления), такие как таблицы и кнопки, а также вспомогательные
или служебные компоненты, предоставляющие определенный набор функций, используемых в других компонентах. К другому типу распространенных компонентов относятся ресурсоемкие компоненты, доступ к которым осуществляется нечасто, и активация которых выполняется «точно вовремя» (just-in-time, JIT) (обычно используется в сценариях с удаленными или распределенными компонентами); и компоненты с очередью, вызовы методов которых могут выполняться асинхронно за счет применения очереди сообщений, для хранения и пересылки. Компоненты зависят от механизмов платформы, обеспечивающей среду выполнения. Часто эти механизмы называют просто компонентной архитектурой. Примерами такой архитектуры могут служить Объектная модель программных компонентов (component object model, COM) и Объектная модель распределенных программных компонентов (distributed component object model, DCOM) в Windows, Общая архитектура брокера объектных запросов (Common Object Request Broker Architecture, CORBA) и Серверные компоненты Java (Enterprise
JavaBeans, EJB) на других платформах. Используемая компонентная архитектура описывает механизмы размещения компонентов и их интерфейсов, передачи сообщений или команд между компонентами и, в некоторых случаях, сохранения состояния.
Однако термин компонент часто используется в более общем смысле как составная часть, элемент или составляющая. Microsoft .NET Framework предоставляет поддержку для построения приложений с использованием такого компонентного подхода.
Основные преимущества компонентного архитектурного стиля:
●	  Простота развертывания. Существующие версии компонентов могут заменяться
новыми совместимыми версиями, не оказывая влияния на другие компоненты или
систему в целом.
●	  Меньшая стоимость. Использование компонентов сторонних производителей
позволяет распределять затраты на разработку и обслуживание.
●	  Простота разработки. Для обеспечения заданной функциональности компоненты
реализуют широко известные интерфейсы, что позволяет вести разработку без влияния
на другие части системы.
●	  Возможность повторного использования. Применение многократно используемых
компонентов означает возможность распределения затрат на разработку и
обслуживание между несколькими приложениями или системами.
●	  Упрощение с технической точки зрения. Компоненты упрощают систему через
использование контейнера компонентов и его сервисов. В качестве примеров
сервисов, предоставляемых контейнером, можно привести активацию компонентов,
управление жизненным циклом, организацию очереди вызовов методов, обработку
событий и транзакции.
Для управления зависимостями между компонентами, поддержки слабого связывания и
повторного использования могут использоваться шаблоны проектирования, такие как
Dependency Injection (Внедрение зависимостей) или Service Locator (Локатор сервиса). Такие шаблоны часто применяются при создании составных приложений, сочетающих и повторно использующих компоненты во многих приложениях. Рассмотрите возможность применения компонентой архитектуры, если уже располагаете подходящими компонентами или можете получить их от сторонних производителей; если
предполагается, что создаваемое приложение будет преимущественно выполнять
процедурные функции, возможно, с небольшим количеством вводимых данных или вообще без таковых; или если хотите иметь возможность сочетать компоненты, написанные на разных языках программирования. Также этот стиль подойдет для создания подключаемой или составной архитектуры, которая позволяет без труда заменять и обновлять отдельные компоненты.

20. Проектирование на основе предметной области.
Проектирование на основе предметной области (Domain Driven Design, DDD) – это объектно-ориентированный подход к проектированию ПО, основанный на предметной области, ее элементах, поведении и отношениях между ними. Целью является создание программных систем, являющихся реализацией лежащей в основе предметной области, путем определения модели предметной области, выраженной на языке специалистов в этой области. Модель предметной области может рассматриваться как каркас, на основании которого будут реализовываться решения.Для применения DDD необходимо четко понимать предметную область, которую предполагается моделировать, или иметь способности для овладения такими знаниями. При создании модели предметной области группа разработки нередко работает в сотрудничестве со специалистами в данной области. Архитекторы, разработчики и специалисты в рассматриваемой области обладают разной подготовкой и во многих ситуациях будут использовать разные языки для описания своих целей, желаний и требований. Однако в рамках DDD вся группа договаривается использовать только один язык, ориентированный на предметную область и исключающий все технические жаргонизмы.
В качестве ядра ПО выступает модель предметной области, которая является прямой
проекцией этого общего языка; с ее помощью путем анализа языка группа быстро находит
пробелы в ПО. Создание общего языка это не просто упражнение по получению сведений от специалистов и их применению. Довольно часто в группах возникают проблемы с обменом информацией не только по причине непонимания языка предметной области, но также и из-за неопределенности языка самого по себе. Процесс DDD имеет целью не только реализацию используемого языка, но также улучшение и уточнение языка предметной области. Это, в свою очередь, положительно отражается на создаваемом ПО, поскольку модель является прямой проекцией языка предметной области.
Чтобы сделать модель строгой и полезной языковой конструкцией, как правило, приходится интенсивно использовать изоляцию и инкапсуляцию в рамках модели предметной области. Это может обусловить относительную дороговизну системы, основанной на DDD. Несмотря на то, что DDD обеспечивает массу преимуществ с технической точки зрения, таких как удобство в обслуживании, эта схема должна применяться лишь для сложных предметных областей, для
которых процессы моделирования и лингвистического анализа обеспечивают безусловные преимущества при обмене сложной для понимания информацией и формулировании общего видения предметной области. Основными преимуществами стиля DDD являются:
●	  Обмен информацией. Все участники группы разработки могут использовать модель предметной области и описываемые ею сущности для передачи сведений и требований предметной области с помощью общего языка предметной области, не прибегая к техническому жаргону.
●	  Расширяемость. Модель предметной области часто является модульной и гибкой, что упрощает обновление и расширение при изменении условий и требований.
●	  Удобство тестирования. Объекты модели предметной области характеризуются слабой связанностью и высокой связность, что облегчает их тестирование.
DDD применяют при работе со сложной предметной областью,если необходимо улучшить процессы обмена информацией и ее понимания группой разработки,или если необходимо представить проект приложения на общем языке, понятном всем заинтересованным сторонам. DDD также может быть идеальным подходом для сценариев обработки больших объемов сложных данных предприятия, с которыми сложно справится, используя другие методики.

21. Многослойная архитектура.
Многослойная архитектура (n-tier client-server architecture) - клиент-серверная архитектура, где процессы представления, обработки и управления данными  являются логически отделенными друг от друга процессами. Модель многослойной архитектуры  помогает создать гибкое и многократно  используемое программное обеспечение. В случае изменений надо их делать лишь в отдельных слоях, а не сразу во всем приложении. Это сулит  меньше работы, меньших затрат времени и меньше потенциальных ошибок.
Более типичным и более используемым вариантом является  трехслойная архитектура (three-tier client server architecture). В случае трехслойного приложения каждый слой располагается в разных местах в  компьютерной сети и может располагаться также на разных платформах.
К пользователю ближе всего  находящееся в его компьютере программное обеспечение рабочей станции (так называемый  слой логики представления). Этот слой может отводиться формам ввода  и типичному на данной платформе графическому пользовательскому интерфейсу. Не исключено существование  этого слоя на различных платформах. Слой логики представления взаимодействует со слоем логики приложения (также слой бизнес-логики, средний слой).
Задача бизнес-логики или слоя логики фирмы (компании) - управлять функциональностью, обрабатывая для этого полученные с нижнего слоя  данные  в соответствии с запросами пользователя, пришедшими  с верхнего слоя.  Этот слой обычно находится на сервере локальной сети.
Слой данных - это третий слой. Он включает в себя базу данных и необходимое для ее управления программное обеспечение  и может располагаться на некотором мейнфрейме. Слой отвечает среди прочего за сохранение данных независимо от приложения и логики представления.
Обобщением является многослойная архитектура (n-tier architcture). Здесь различные слои могут добавляться по мере необходимости (или описанные слои могут быть разделены, в свою очередь, на части). В ситуации, когда все большая ценность имеется не у одиночных приложений или баз данных, а у взаимодействующих информационных систем,  узкое место в разработке  переместилось в сторону создания интерфейсов и интеграции систем. Немаловажно использовать проверенные практики (например, шаблоны для разрешения аналогичных проблем), сервис-ориентированный подход, семантическое описание информационных систем.

22. Архитектура, основанная на шине сообщений.
Основанная на шине сообщений архитектура описывает принцип использования программной системы, которая может принимать и отправлять сообщения по одному или более каналам связи, обеспечивая, таким образом, приложениям возможность взаимодействия без необходимости знания конкретных деталей друг о друге. Это стиль проектирования, в котором взаимодействия между приложениями осуществляются путем передачи (обычно асинхронной) сообщений через общую шину. В типовых реализациях архитектуры, основанной на шине сообщений, используется либо маршрутизатор сообщений, либо шаблон Publish/Subscribe (Публикация/Подписка) и система обмена сообщениями, такая как Message Queuing (Очередь сообщений). Многие реализации состоят из отдельных приложений, обмен данными между которыми осуществляется путем отправки и приема сообщений по общим
схемам и инфраструктуре. Шина сообщений обеспечивает возможность обрабатывать:
●	  Основанное на сообщениях взаимодействие. Все взаимодействие между
приложениями основывается на сообщениях, использующих известные схемы.
●	  Сложную логику обработки. Сложные операции могут выполняться как часть
многошагового процесса путем сочетания ряда меньших операций, каждая из которых
поддерживает определенные задачи.
●	  Изменения логики обработки. Взаимодействие с шиной реализуется по общим схемам и с применением обычных команд, что обеспечивает возможность вставки или удаления приложений на шине для изменения используемой для обработки
сообщений логики.
●	  Интеграцию с разными инфраструктурами. Использование модели связи посредством сообщений, основанной на общих стандартах, позволяет взаимодействовать с приложениями, разработанными для разных инфраструктур, таких как Microsoft .NET и Java.
Шины сообщений используются для обеспечения сложных правил обработки уже в течение
многих лет. Такой дизайн обеспечивает подключаемую архитектуру, которая позволяет
вводить приложения в процесс или улучшать масштабируемость, подключая к шине несколько
экземпляров одного и того же приложения. К разновидностям шины сообщений относятся:
●	  Сервисная шина предприятия (Enterprise Service Bus, ESB). ESB основывается на шине сообщений и использует сервисы для обмена данными между шиной и компонентами, подключенными к шине. Обычно ESB обеспечивает сервисы для преобразования одного формата в другой, обеспечивая возможность связи между клиентами, использующими несовместимые форматы сообщений.
●	  Шина Интернет-сервисов (Internet Service Bus, ISB). Подобна сервисной шине
предприятия, но приложения размещаются не в сети предприятия, а в облаке. Основная идея ISB – использование Унифицированных идентификаторов ресурсов (Uniform Resource Identifiers, URIs) и политик, управляющих логикой маршрутизации через приложения и сервисы в облаке.
К основным преимуществам архитектуры, основанной на шине сообщений, относятся:
●	  Расширяемость. Возможность добавлять или удалять приложения с шины без влияния на существующие приложения.
●	  Невысокая сложность. Приложения упрощаются, потому что каждому из них
необходимо знать лишь, как обмениваться данными с шиной.
●	  Гибкость. Приведение набора приложений, составляющих сложный процесс, или схем связи между приложениями в соответствие изменяющимся бизнес-требованиям или требованиям пользователя просто путем внесения изменений в конфигурацию или параметры, управляющие маршрутизацией.
●	  Слабое связывание. Кроме предоставляемого приложением интерфейса для связи с шиной сообщений, нет никаких других зависимостей с самим приложением, что обеспечивает возможность изменения, обновления и замены его другим
приложением, предоставляющим такой же интерфейс.
●	  Масштабируемость. Возможность подключения к шине множества экземпляров
одного приложения для обеспечения одновременной обработки множества запросов.
●	  Простота приложения. Несмотря на то, что реализация шины сообщений усложняет инфраструктуру, каждому приложению приходится поддерживать лишь одно подключение к шине сообщений, а не множество подключений к другим
приложениям.


23. N-уровневая / 3-уровневая архитектура.
N-уровневая и 3-уровневая архитектура являются стилями развертывания, описывающими разделение функциональности на сегменты, во многом аналогично многослойной архитектуре, но в данном случае эти сегменты могут физически размещаться на разных компьютерах, их называют уровнями.
      Данные архитектурные стили были созданы на базе компонентно-ориентированного подхода и, как правило, для связи используют методы платформы, а не сообщения.
      Характеристиками N-уровневой архитектуры приложения являются функциональная декомпозиция приложения, сервисные компоненты и их распределенное развертывание, что обеспечивает повышенную масштабируемость, доступность, управляемость и эффективность использования ресурсов. Каждый уровень абсолютно независим от всех остальных, кроме тех, с которыми он непосредственно соседствует. N-ному уровню требуется лишь знать, как обрабатывать запрос от n+1 уровня, как передавать этот запрос на n-1 уровень (если таковой имеется), и как обрабатывать результаты запроса. Для обеспечения лучшей масштабируемости связь между уровнями обычно асинхронная.
      N-уровневая архитектура обычно имеет не менее трех отдельных логических частей, каждая из которых физически размещается на разных серверах. Каждая часть отвечает за определенную функциональность. При использовании многослойного подхода слой развертывается на уровне, если предоставляемая этим слоем функциональность используется более чем одним сервисом или приложением уровня.
     Примером N-уровневого/3-уровневого архитектурного стиля может служить типовое финансовое Веб-приложение с высокими требованиями к безопасности. Бизнес-слой в этом случае должен быть развернут за межсетевым экраном, из-за чего приходится развертывать слой представления на отдельном сервере в пограничной сети. Другой пример – типовой насыщенный клиент, в котором слой представления развернут на клиентских компьютерах, а бизнес-слой и слой доступа к данным развернуты на одном или более серверных уровнях.
      Основными преимуществами N-уровневого/3-уровневого архитектурного стиля являются:
●	Удобство поддержки. Уровни не зависят друг от друга, что позволяет выполнять обновления или изменения, не оказывая влияния на приложение в целом.
●	Масштабируемость. Уровни организовываются на основании развертывания слоев, поэтому масштабировать приложение довольно просто.
●	Гибкость. Управление и масштабирование каждого уровня может выполняться независимо, что обеспечивает повышение гибкости.
●	Доступность. Приложения могут использовать модульную архитектуру, которая позволяет использовать в системе легко масштабируемые компоненты, что повышает доступность.
      Рассмотрите возможность применения N-уровневой или 3-уровневой архитектуры, если требования по обработке уровней приложения отличаются настолько сильно, что может возникнуть перекос в распределении ресурсов, или существенно разнятся требования по безопасности уровней. Например, конфиденциальные данные не должны храниться на уровне представления, но могут размещаться на бизнес-уровне или уровне данных. N-уровневая или 3-уровневая архитектура также подойдет в случае, если требуется обеспечить возможность совместного использования бизнес-логики разными приложениями и имеется достаточное количество оборудования для выделения необходимого числа серверов для каждого уровня.
        Используйте только три уровня, если создаете приложение для внутренней сети организации, где все серверы будут располагаться в закрытой сети; или Интернет-приложение, требования по безопасности которого не запрещают развертывание бизнес-логики на Веб-сервере или сервере приложений. Рассмотрите возможность применения более трех уровней, если соответственно требованиям по безопасности бизнес-логика не может быть развернута в пограничной сети, или если приложение интенсивно использует ресурсы, и для разгрузки сервера необходимо перенести эту функциональность на другой сервер.
